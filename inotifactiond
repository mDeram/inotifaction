#!/bin/sh

DAEMON_NAME="inotifactiond"

DAEMONSTATE_active=1
DAEMONSTATE_inactive=0

SAVE_DIR=$HOME/.inotifaction
SAVE_LOG_DIR=$SAVE_DIR/log
SAVE_PID_DIR=$SAVE_DIR/pid
SAVE_ERR_DIR=$SAVE_DIR/err # or /dev/null

CONFIG_DIR=$HOME/.config/inotifaction/config
SCRIPT=./scripts/relocator

WATCH=$HOME/Pictures/screenshots

daemonize() {
    export PATH=$PWD:$PATH
    cd /
    #umask 022 do we want a umask here ? I don't think so
    nohup setsid $0 DAEMON $* 2>$SAVE_ERR_DIR >$SAVE_LOG_DIR & jobs -p > $SAVE_PID_DIR
}

start() {
    getDaemonStatus
    if [ "$?" = "$DAEMONSTATE_active" ]; then
        echo "Currently active"
        return 1
    fi

    echo "Checking if the save directory exists"
    mkdir -p -- "$SAVE_DIR"
    if [ ! -d "$SAVE_DIR" ]; then
        echo "Missing directory ${SAVE_DIR} & cannot be created"
        echo "Try 'mkdir ${SAVE_DIR}' or run the install file" 
        exit 1
    fi
    echo "Ok"

    echo "Starting inotifaction daemon"
    daemonize
    echo "Daemon started"
}

stop() {
    # This is safe because either the pid is taken by the inotifaction daemon
    # or by nothing since the only unsafe case would be:
    #
    # The pid correspond to the inotifaction daemon, then its killed, then
    # another program take that pid which is impossible since pids are
    # incremental so the system would need a restart thus killing that script.
    # So that unsafe case isn't possible.
    #
    # We are safe :)

    # Getting the pid before make sure the pid is not changed after calling
    # getDaemonStatus, thus preventing this program to kill other process
    daemon_pid=$(cat $SAVE_PID_DIR)
    getDaemonStatus $daemon_pid
    if [ "$?" = "$DAEMONSTATE_inactive" ]; then
        echo "Currently inactive"
        return 1
    fi
    kill $daemon_pid 
    echo "Daemon killed"
}

# getDaemonStatus [pid]
getDaemonStatus() {
    # Get the pid from params or from the pid file
    daemon_pid="${1:-$(cat $SAVE_PID_DIR)}"
    # Check pid not empty
    if [ "$daemon_pid" = "" ]; then
        return $DAEMONSTATE_inactive
    fi

    daemon_pid_name=$(ps -p $daemon_pid -o comm=) 
    #if [ "$daemon_pid_name" = "$0" ]; then
    if [ "$daemon_pid_name" = "$DAEMON_NAME" ]; then
        return $DAEMONSTATE_active
    else
        return $DAEMONSTATE_inactive
    fi
}

status() {
    getDaemonStatus
    case $? in
        $DAEMONSTATE_active)    echo "Active"   ;;
        $DAEMONSTATE_inactive)  echo "Inactive" ;;
    esac
}

if [ "$1" = "DAEMON" ]; then
    trap '' INT
    shift # Shift args to the left
    
    ### Daemonized section ###
    inotifywait -m -e close_write ${WATCH} | xargs -n3 ${SCRIPT} &
    wait
    ### End of daemonized section ###

    exit 0
else
    case "${1}" in
        start)
            start
            ;;
        stop)
            stop
            ;;
        restart)
            stop
            start
            ;;
        status)
            status
            ;;
        *)
            echo "Usage: ${0} {start|stop|restart|status}"
            exit 1
    esac
fi
